<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linear Systems Solver: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Linear Systems Solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://www.epfl.ch/"></a> </p>
<h1>MATH-458 - PCSC - Linear solvers</h1>
<p>This C++ project consist in solving linear system <em>Ax = b</em> by different methods.</p>
<p>7 solvers are implemented : <a class="el" href="class_l_u.html" title="LU decomposition. ">LU</a> decomposition, <a class="el" href="class_cholesky.html" title="Cholesky decomposition. ">Cholesky</a> decomposition, Conjugate Gradient Descent, Preconditioned Conjugate Gradient Descent, <a class="el" href="class_jacobi.html" title="Jacobi method. ">Jacobi</a>, Gauss-Seidel, and <a class="el" href="class_richardson.html" title="Richardson method. ">Richardson</a> method. The first two solvers are direct methods and the others are iterative methods.</p>
<p>This project is a part of the course : "*Programming Concepts in Scientific Computing*" given at EPFL by <b>Guillaume Anciaux</b> in fall 2017.</p>
<p><b>Authors : Muhammad Haziq Bin Razali, Arnaud Pannatier</b></p>
<p>Group 8 </p><h2>Compilation and Execution</h2>
<ol type="1">
<li>Clone this repository <div class="fragment"><div class="line">$ git clone https://github.com/ArnaudPannatier/PCSC2017_Group8.git</div></div><!-- fragment --></li>
</ol>
<h3>CMake</h3>
<ol type="1">
<li>Create a build directory <div class="fragment"><div class="line">$ cd PCSC2017_Group8/</div><div class="line">$ mkdir build</div><div class="line">$ cd build</div></div><!-- fragment --></li>
<li>Run CMake <div class="fragment"><div class="line">cmake ..</div><div class="line">make</div></div><!-- fragment --></li>
</ol>
<p>The google test API is downloaded during the build by CMake. If it does not work, please redo the cmake command.</p>
<h3>Clion</h3>
<ol type="1">
<li>Ensure that you have <a href="https://www.jetbrains.com/clion/">Clion</a> installed (tested on clion version 2017.2 on ubuntu and MacOSX)</li>
<li>Launch clion via bash <div class="fragment"><div class="line">$ clion</div></div><!-- fragment --></li>
<li>Set the working directory to the root of the cloned file</li>
<li>Run the demo by setting the Run/Debug configuration dialog box to demo then clicking on Run (Green Arrow)</li>
</ol>
<h2>Using the programm</h2>
<h3>Executable</h3>
<p>The simplest way of using the program is to simply run the executable with the proper arguments.</p>
<h4>If you just want to solve the matrix</h4>
<p>the syntax expected is :</p>
<div class="fragment"><div class="line">$ ./Main A.txt B.txt</div></div><!-- fragment --><p> and it will use Conjugate gradient descend to solve the system.</p>
<h4>If the solver is known</h4>
<p>the syntax expected is : </p><div class="fragment"><div class="line">$ ./Main Solver A.txt B.txt [optionnal] X.txt eps max_iter preconditionner/omega</div></div><!-- fragment --><h5>In particular :</h5>
<p>For direct solvers (LU/Cholesky) : </p><div class="fragment"><div class="line">$ ./Main Solver A.txt B.txt</div></div><!-- fragment --><p>For iterative solvers : </p><div class="fragment"><div class="line">$ ./Main Solver A.txt B.txt [optionnal] X.txt eps max_iter</div></div><!-- fragment --> <h5>Special cases:</h5>
<p>Preconditionate Conjugate Gradient : </p><div class="fragment"><div class="line">$ ./Main Solver A.txt B.txt [optionnal] X.txt eps max_iter preconditionner</div></div><!-- fragment --><p>preconitionner values : Jacobi/GaussSeidel for <a class="el" href="class_jacobi.html" title="Jacobi method. ">Jacobi</a> or <a class="el" href="class_gauss_seidel.html" title="Gauss-Seidel Method. ">GaussSeidel</a> preconditionners</p>
<p><a class="el" href="class_richardson.html" title="Richardson method. ">Richardson</a>: </p><div class="fragment"><div class="line">$ ./Main Solver A.txt B.txt [optionnal] X.txt eps max_iter omega</div></div><!-- fragment --><h3>CLion</h3>
<p>The cases described bellow can be applied in CLion by using <em>Edit Configuration</em> of the executable.</p>
<h3>From cin</h3>
<p>You can run : </p><div class="fragment"><div class="line">$ ./Main.cpp</div></div><!-- fragment --><p>and the needed arguments will be asked by the program.</p>
<h2>Typical program execution (the flow)</h2>
<p>The program typically starts by instantating a <a class="el" href="class_matrix.html" title="2-dimensional matrix class ">Matrix</a> and <a class="el" href="class_vector.html" title="1-dimensional Vector class ">Vector</a> object. This can be done in 2 ways: by reading from a text file, or by coding it manually as shown below. Note that each row of the `Matrix A represents a single equation.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">inputOutput io;</div><div class="line">Matrix A1 = io.readFromText(&quot;A1.txt&quot;);</div><div class="line">Vector b1 = Vector(io.readFromText(&quot;B1.txt&quot;));</div><div class="line"></div><div class="line">const Matrix A2({{1,1,-1},{1,-2,3},{2,3,-1}});</div><div class="line">const Vector B2({4,-6,7});</div></div><!-- fragment --><p>The user can then instantiate a solver from the list below. Note that some of the iterative methods require an initial guess x_0 to the solution to Ax = b and more arguments.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">// Example of running the conjugate gradient method</div><div class="line">Vector x_0({2,1});</div><div class="line">ConjugateGradientDescent conjSolver(A2, B2, x_0);</div><div class="line">Vector X_sol_conj = conjSolver.solve();</div><div class="line"></div><div class="line">// Example of running the jacobi</div><div class="line">Jacobi jacobi(A2,B2);</div><div class="line">Vector X_sol_jacobi = jacobi2.solve();</div></div><!-- fragment --><p>Lastly, the contents of any <a class="el" href="class_matrix.html" title="2-dimensional matrix class ">Matrix</a> and <a class="el" href="class_vector.html" title="1-dimensional Vector class ">Vector</a> can be easily viewed using the output steam operator which has been overloaded to handle the <a class="el" href="class_matrix.html" title="2-dimensional matrix class ">Matrix</a> and <a class="el" href="class_vector.html" title="1-dimensional Vector class ">Vector</a> class. </p><div class="fragment"><div class="line">{c++}</div><div class="line">cout &lt;&lt; X_conjSolver &lt;&lt; endl;</div><div class="line">cout &lt;&lt; X_jacobi &lt;&lt; endl;</div></div><!-- fragment --><h2>List of Features</h2>
<h3>Available solvers</h3>
<p>Below are the list of implemented solvers and their constructors.</p>
<h4>Direct solvers :</h4>
<ul>
<li><p class="startli"><a class="el" href="class_l_u.html" title="LU decomposition. ">LU</a></p>
<p class="startli">Implements the <a class="el" href="class_l_u.html" title="LU decomposition. ">LU</a> decomposition of a matrix based on Crout's algorithm that returns a lower triangular matrix and a unit upper triangular matrix.</p>
<p class="startli"><a href="https://en.wikipedia.org/wiki/Crout_matrix_decomposition">https://en.wikipedia.org/wiki/Crout_matrix_decomposition</a></p>
</li>
</ul>
<div class="fragment"><div class="line">{c++}</div><div class="line">LU(A, B, opts[X_0])</div></div><!-- fragment --><ul>
<li><a class="el" href="class_cholesky.html" title="Cholesky decomposition. ">Cholesky</a></li>
</ul>
<p>Implements the <a class="el" href="class_cholesky.html" title="Cholesky decomposition. ">Cholesky</a> decomposition of a matrix that returns a lower triangular matrix and its transpose. It's a special case of <a class="el" href="class_l_u.html" title="LU decomposition. ">LU</a> decomposition when the matrix A is symmetric.</p>
<p><a href="https://en.wikipedia.org/wiki/Cholesky_decomposition">https://en.wikipedia.org/wiki/Cholesky_decomposition</a></p>
<div class="fragment"><div class="line">{c++}</div><div class="line">Cholesky(A,B, opts[X_0])</div></div><!-- fragment --><h4>Iterative solvers :</h4>
<ul>
<li>Conjugate Gradient Descent</li>
</ul>
<p>Implements the method for conjugate gradient descent. Which has the property to converge when the matrix is symmetric definite positive. In the other cases, the convergence can appear as well but with no guarantee.</p>
<p><a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">https://en.wikipedia.org/wiki/Conjugate_gradient_method</a></p>
<div class="fragment"><div class="line">{c++}</div><div class="line">ConjugateGradientDescent(A, B, opts[ X_0, epsilson, max_iter ])</div></div><!-- fragment --><ul>
<li>Preconditionate Gradient Descent</li>
</ul>
<p>Implements the method for preconditioned gradient descent. Preconditioning will ensure that the matrix has a smaller condition number. This should lead to a faster and numerically more stable convergence.</p>
<p><a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">https://en.wikipedia.org/wiki/Conjugate_gradient_method</a></p>
<div class="fragment"><div class="line">{c++}</div><div class="line">PCConjugateGradientDescent(A,B, P, opts[ X_0, epsilson, max_iter ])</div></div><!-- fragment --><ul>
<li>Gauss Seidel</li>
</ul>
<p>Implements the Gauss-Seidel method for solving a system of linear equations.</p>
<p><a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method">https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method</a></p>
<div class="fragment"><div class="line">{c++}</div><div class="line">GaussSeidel(A, B, opts[ X_0, epsilson, max_iter ])</div></div><!-- fragment --><ul>
<li><a class="el" href="class_jacobi.html" title="Jacobi method. ">Jacobi</a></li>
</ul>
<p>Implements the <a class="el" href="class_jacobi.html" title="Jacobi method. ">Jacobi</a> method for solving a system of linear equations</p>
<p><a href="https://en.wikipedia.org/wiki/Jacobi_method">https://en.wikipedia.org/wiki/Jacobi_method</a></p>
<div class="fragment"><div class="line">{c++}</div><div class="line">Jacobi(A, B, opts[ X_0, epsilson, max_iter ])</div></div><!-- fragment --><ul>
<li><a class="el" href="class_richardson.html" title="Richardson method. ">Richardson</a></li>
</ul>
<p>Implements the <a class="el" href="class_richardson.html" title="Richardson method. ">Richardson</a> Method for solving a system of linear equations</p>
<p><a href="https://en.wikipedia.org/wiki/Modified_Richardson_iteration">https://en.wikipedia.org/wiki/Modified_Richardson_iteration</a></p>
<div class="fragment"><div class="line">{c++}</div><div class="line">Richardson(A, B, omega, opts[ X_0, epsilson, max_iter ]);</div></div><!-- fragment --><h3>Types</h3>
<ul>
<li><a class="el" href="class_matrix.html" title="2-dimensional matrix class ">Matrix</a></li>
</ul>
<p>Class that represents Matrices. They can be of any size. An instance of this class can be created from <code>vector&lt;vector&lt;double&gt;&gt;</code>, <code>initializer_list</code> and can also be read from files using the reader.</p>
<p>Operator +,-, *double, *Matrix, =,[ ],() have been overloaded to allow pratical computation. Operator &lt;&lt; and &gt;&gt; have been overloaded to allow practical display and practical translation from string.</p>
<p>Some typical methods for matrices as <code>Transpose()</code>, <code>Inverse()</code> ... also have been implemented.</p>
<ul>
<li><a class="el" href="class_vector.html" title="1-dimensional Vector class ">Vector</a></li>
</ul>
<p>Inherit from <a class="el" href="class_matrix.html" title="2-dimensional matrix class ">Matrix</a> class. Represent vector type.</p>
<p>Some practical methods for vectors as scalar product : <code>dot()</code>, norm induced from scalar product : <code>norm()</code>, ... also have been implemented.</p>
<h3>Reader and writer</h3>
<p>A class reader is provided in order to create an instance of <a class="el" href="class_matrix.html" title="2-dimensional matrix class ">Matrix</a> from a .txt file.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">Matrix A = inputOutput::readFromText(&quot;A.txt&quot;);</div></div><!-- fragment --><p>A writer was also implemented if one want to output the results in a file instead of printing it in the terminal.</p>
<h3><a class="el" href="class_solver.html" title="Base class for linear solvers. ">Solver</a> Factory</h3>
<p>A solver factory is implemented to create the <a class="el" href="class_solver.html" title="Base class for linear solvers. ">Solver</a> that the user want. It takes as input the parameters that the user provides either in the <em>arguments</em> or in the <em>cin</em> and return a pointer to a <a class="el" href="class_solver.html" title="Base class for linear solvers. ">Solver</a>.</p>
<p>The resolution is then made taking use of the polymorphism of the class.</p>
<p>A templated function <code>stoClass</code> which translate string to object have also been implemented. It was practical for the solver factory.</p>
<h3>Example of linear systems</h3>
<p>Example of linear systems can be found in the folder Examples.</p>
<h2>List of tests</h2>
<p>The tests are implemented using Google Test Suite.</p>
<p><a href="https://github.com/google/googletest">https://github.com/google/googletest</a></p>
<p>To run all the test, run the following command :</p>
<div class="fragment"><div class="line">./Test</div></div><!-- fragment --><p>The google test API is downloaded during the build by CMake. If it does not work, please redo the cmake process.</p>
<h3><a class="el" href="class_matrix.html" title="2-dimensional matrix class ">Matrix</a> and <a class="el" href="class_vector.html" title="1-dimensional Vector class ">Vector</a></h3>
<ul>
<li>All constructors have been tested for the <a class="el" href="class_matrix.html" title="2-dimensional matrix class ">Matrix</a> and <a class="el" href="class_vector.html" title="1-dimensional Vector class ">Vector</a> classes.</li>
<li>Mutator and Accessor have been tested.</li>
<li>The copy constructor was tested too.</li>
<li>TODO : Tests for the differents operator : +,-,* and methods translate(), inverse(), dot(), norm().</li>
</ul>
<h3><a class="el" href="class_solver.html" title="Base class for linear solvers. ">Solver</a></h3>
<ul>
<li>All the solver have been tested on the base case provided in the Example Folder.</li>
<li>TODO : Test the solvers in different cases.</li>
</ul>
<h3><a class="el" href="class_solver.html" title="Base class for linear solvers. ">Solver</a> Factory</h3>
<ul>
<li>The template function <code>stoClass</code> have been tested in the case of <code><a class="el" href="class_vector.html" title="1-dimensional Vector class ">Vector()</a></code>, <code>double</code>, <code>size_t</code>. Which are used by the programm.</li>
<li>Test for the solver factory, all solvers are tested.</li>
</ul>
<h2>TODOs and perspectives</h2>
<ul>
<li>Add tests for all the cases that are not treated for now.</li>
<li>Test the solver with more examples of linear systems.</li>
<li>Add new preconditioners.</li>
<li>Implement the preconditioners for more iterative solvers.</li>
<li>Compute <em>omega</em> for <a class="el" href="class_richardson.html" title="Richardson method. ">Richardson</a> method using the power method to find the eigenvalues. Knowing that <em>omega</em> = 2/(<em>lambda</em>_min + <em>lambda</em>_max)</li>
<li>More control on the cin input of the solver factory.</li>
<li>Add more organization in the tests </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
